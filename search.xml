<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript 模块的演变]]></title>
    <url>%2Fzh%2F2018%2F01%2F08%2FJavaScript%20%E6%A8%A1%E5%9D%97%E7%9A%84%E6%BC%94%E5%8F%98%2F</url>
    <content type="text"><![CDATA[ES6 带来的原生 JavaScript 模块体系，相信你已经用起来了，如果还没有，那你还有时间看文章？看什么看，你还不赶紧去用用。 转载：原生 JavaScript 模块的现在与未来 JavaScript 一开始并没有内建模块化支持，也几乎没有模块化这种概念。当时没那么大的需求，搞个模块化显得大材小用啊。随着互联网的发展，尤其是 2006 年 ajax 技术的出现和之后 Web 2.0 的兴起，越来越多的业务逻辑向前端转移，前端开发的复杂程度和代码量逐渐提升。这时，由于缺乏模块化概念，JavaScript 的一些问题便凸显出来：代码难以复用、容易出现全局变量污染和命名冲突、依赖管理难以维护等等。一开始，开发者们使用诸如暴露全局对象、自执行函数等方法来规避这些问题，但仍无法从根本上解决问题。 CommonJS2009 年，基于将 JavaScript 应用于服务端的尝试，ServerJS 诞生了。之后 ServerJS 更名为 CommonJS，并逐步发展为一个完整的模块规范。简称 CMD（Common Module Definition） CommonJS官网CommonJS阮一峰 CommonJS 为模块的使用定义了一套 API。比如，它定义了全局函数 require，通过传入模块标识来引入其他模块，如果被引入的模块又依赖了其他模块，那么会依次加载这些模块；通过 module.exports 向外部暴露 API，以便其他的模块引入。 由于 CommonJS 是使用同步方式加载模块的，即只有加载完成才能进行接下来的操作，因此当应用于浏览器端时会受到网速的限制。 123456789101112131415const $ = require('jquery')// 定义私有方法function log (...arg) &#123; console.log(...arg)&#125;// 定义公有方法function sayHello () &#123; const el = $('body') log('zhouyu, hello', el)&#125;// 暴露公有方法module.exports = &#123; sayHello&#125; AMD之后，在 CommonJS 组织的讨论中，AMD（Asynchronous Module Definition）应运而生。和 CommonJS 不同的是，它使用异步方式加载模块，因此更适合被浏览器端采用。AMD 用全局函数 define 来定义模块，它需要三个参数：模块名称、模块的依赖数组、所有依赖都可用之后执行的回调函数（该函数按照依赖声明的顺序，接收依赖作为参数）。 AMDAMD中文 12345678910111213define(['jquery'], function ($) &#123; // 定义私有方法 function log (...arg) &#123; console.log(...arg) &#125; // 定义公有方法 function sayHello () &#123; const el = $('body') log('zhouyu, hello', el) &#125; // 暴露公有方法 return sayHello&#125;) UMD如果需要同时支持 CommonJS 和 AMD 两种格式，那么可以使用 UMD（Universal Module Definition）。事实上，UMD 通过一系列 if/else 判断来确定当前环境支持的模块体系，因此多数情况下 UMD 格式的模块会占用更大的体积。 123456789101112131415161718192021222324(function (root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD define(['jquery'], factory) &#125; else if (typeof exports === 'object') &#123; // Nodejs 或 CommonJS module.exports = factory(require('jquery')) &#125; else &#123; // 浏览器全局变量(root 即 window) root.returnExports = factory(root.jQuery) &#125;&#125;(this, function ($) &#123; // 定义私有方法 function log (...arg) &#123; console.log(...arg) &#125; // 定义公有方法 function sayHello () &#123; const el = $('body') log('zhouyu, hello', el) &#125; // 暴露公有方法 return sayHello&#125;)); ES6 Modules无论是 CommonJS，AMD 还是 UMD，它们都不是标准的 JavaScript 模块解决方案。换句话说，它们都没有被写进 ECMA 的规范中。直到 2015 年 6 月，TC39 委员会终于将 Modules 写进 ECMAScript 2015 中，标志着原生模块新时代的到来。至此，JavaScript 文件有了两种形式：脚本（自 JavaScript 诞生起我们就在使用的）和模块（即 ECMAScript 2015 Modules）。下面就让我们来一起探索 ECMAScript 2015 Modules（以下简称 ES6 Modules） ES6 ModulesES6阮一峰 12345678910111213import $ from('jquery')// 定义私有方法function log (...arg) &#123; console.log(...arg)&#125;// 定义公有方法function sayHello () &#123; const el = $('body') log('zhouyu, hello', el)&#125;export default sayHello ES6 Modules 现状时至今日，几大主流浏览器都在积极推进支持原生 ES6 Modules 的工作，部分浏览器的技术预览版也已经初步完成了这一使命。可以通过 caniuse 查看目前浏览器的支持情况。 使用 Babel 和 webpack由于绝大多数浏览器都不支持 ES6 Modules，所以目前如果想使用它的语法，需要借助 Babel 和 webpack，即通过 Babel 将代码编译为 ES5 的语法，然后使用 webpack 打包成目标格式。 直接使用 ES6 Modules有些游览器已经支持 ES6 Modules，我们利用 &lt;script type=&quot;module&quot;&gt;（默认是 defer）来使用。 其他探索 动态加载方案 import() 1234const load = async (url) =&gt; &#123; const module = await import(url) console.log(module, window[tempGlobal])&#125; 12345678910111213141516171819202122function load (url) &#123; return new Promise((resolve, reject) =&gt; &#123; const script = document.createElement('script') const tempGlobal = '__tempModuleLoadingVariable' + Math.random().toString(32).substring(2) script.type = 'module' script.textContent = `import * as m from "$&#123;url&#125;"; window.$&#123;tempGlobal&#125; = m;` script.onload = () =&gt; &#123; resolve(window[tempGlobal]) delete window[tempGlobal] script.remove() &#125; script.onerror = () =&gt; &#123; reject(new Error('Failed to load module script with URL ' + url)) delete window[tempGlobal] script.remove() &#125; document.documentElement.appendChild(script) &#125;)&#125; 基于 ES6 Modules 的 module-pusher 尝试 查看原文]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好人有好报？]]></title>
    <url>%2Fzh%2F2017%2F12%2F24%2F%E5%A5%BD%E4%BA%BA%E6%9C%89%E5%A5%BD%E6%8A%A5%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[好人有好报，这句话现在似乎变成了鸡汤。 今天是平安夜，本该是成双成对，你侬我侬着，显然我不是。 上午一踏进地铁站，听着地铁工作者特地点播的节日喜庆歌曲，心里却一直荡起，“lonely lonely christmas”，问我的心情，大概是哭笑不得。不过今天是出去旅游观光的，我得表现得 happy 点。 走马观花地看完大报应寺。 大报应寺，是继洛阳白马寺之后中国的第二座寺庙，也是中国南方建立的第一座佛寺。 大报恩寺内琉璃宝塔高达78.2米，通体用琉璃烧制，塔内外置长明灯一百四十六盏，自建成至衰毁一直是中国最高的建筑，也是世界建筑史上的奇迹，位列中世纪世界七大奇迹，被当时西方人视为代表中国的标志性建筑，有“中国之大古董，永乐之大窑器”之誉，被称为“天下第一塔”。 寺内阿育王塔中的佛顶骨舍利是世界现存唯一一枚佛祖（释迦摩尼）真身顶骨舍利，不过现在供奉于南京牛首山的佛顶宫中。 寺内三藏塔中供奉着玄奘法师（唐僧）的顶骨舍利。 南朝四百八十寺，多少楼台烟雨中。如今看风景，已全然没有少时那副怡然自得的欣赏，也不会看到一处就随口吟上一句相应的古诗。 大报应寺，报应报应，因果循环。 《吕祖说三世因果经》主要说的是：一是人的命是自己造就的；二是怎样为自己造一个好命；三是行善积德与行凶作恶干坏事的因果循环报应规律。因果报应指事物的起因和结果，种什么因，结什么果，宗教认为种什么因，结什么果报。 《涅槃经》讲：业有三报，一现报，现作善恶之报，现受苦乐之报；二生报，或前生作业今生报，或今生作业来生报；三速报，眼前作业，目下受报。 俗话说：善有善报，恶有恶报，不是不报，时候未到，时候一到，一切全报。 所以，常听周围说：好人有好报。 上面只是胡扯一通，瞎写一气，狗屁不是，不看也罢，看了无妨。 然而说说接下来的遭遇，报应真的一个接着一个，但我也没干什么坏事啊。 找了一家中华门城头下的羊肉馆，点一份羊杂汤，热乎吃完也罢。站着刚把钱付了，站我对面的是店家一老龄员工，手上端着估计有过百度的一大锅羊肉汤。大概是锅底被高温烫的脱掉了，哗啦啦，滚烫的羊肉汤顿时倾盆而下。恰巧泼到我脚下，我顿时炸毛，可由于这两年体态丰腴了些，敏捷性明显下降，还是慢了，左脚脚背被泼到了。顿时一股灼烧感从脚背传到头皮，疼得我牙痒痒。也不顾着形象了，当场脱了鞋袜。暗自感叹，还好鞋子好，防水，只是左脚一小片烫的发红。 事情发生到着，我先不往下说，各位先代入想想，假如是你遇到这种事情，你会怎么处理？ 去医院和赔钱呗。但我们往往看到是一方抵赖，一方讹钱。我这花钱吃饭，却无端遭了这罪，脚被烫着，凭什么？另外我的鞋子虽然不算贵，也才几百块，经此一泼，虽然发挥些艰苦奋斗的精神，刷一刷还是照穿无误，但凭什么？当然事实是，老板说带我去医院，我说不用了，我也没有提要钱，甚至我都没让老板把我的单免了。脚被烫了一下而已，鞋子脏了而已，能忍则忍了，乡下人老实，不觉得这是多大事。但另一方面，也许是内心软弱吧，也许要被人以鲁迅先生的话训斥为“哀其不幸，怒其不争”。我们经常看到类似新闻，例如有，某一女子（不是歧视女性）的名牌包包被弄脏要求巨额赔偿，甚至说被人厌烦的碰瓷。我这里并不是说，我们遇到这事情，我们不该要求赔偿，如果确实有损失，那么要求赔偿是必然的。甚至是一些严重的事情，第一反应是报警去医院。不要为了钱而要钱，不要越过做人的底线。假如对方不是故意的，你也能够接受，不妨退一步海阔天空，人家也不容易，一大锅汤损失不少钱，不至于捡起来重煮吧。。。 大概看到这里，你会说，好人有好报的。你是在积德行善，将来你会娶个好老婆。 你可知，这只是开始。 我坐在城墙下的路边休息，阳光刺眼，我就闭眼假寐，顺便缓缓脚上的疼痛。突然一堆水溅了过来，不过这次是冷水，泼了我一腿。大哥，冰火两重天不是这么玩的啊，你怎么知道我脚需要降温，但是你浇鞋子就行了，浇我一腿干嘛。我看着晒水车扬长而去，看着那一行“城市清洁”字苦笑，我大概是城市垃圾。 我是不敢坐着了，赶紧站起来，朝着阳光，抖抖自己的裤子，自然风干吧。没过几分钟，哗啦啦，屁股一激灵，低头一看，我呢子大衣上挂着一颗颗水珠，投影着我胖乎乎的脸，我看着他们，他们看着我，仿佛听见一句和声，“傻逼”。不打招呼就来一场雷阵雨，我不想看啊。洒水大哥，你也挺幸苦的啊，政府规定要洒两遍还是咋地，我就站这休息，我犯法了吗，你不能提醒我一下？我是来大报应了吗？ 不深入阐述了，也不说些什么升华的话语，鸡汤虽好喝，但是你们不爱喝啊。 我还活着，活着就好！ 愿你喜乐安好！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>人性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fzh%2F2017%2F12%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
